/**
 * @file executor.c
 * @brief Virtual machine implementation for the Assembly Language Compiler
 * 
 * This file contains the implementation of the virtual machine that executes
 * the intermediate code generated by the compiler.
 * 
 * @copyright Copyright (c) 2017 Komma Ravi Teja
 * @license MIT License
 */

#include "FunctionHeaders.h"

/* External variables from main.c */
extern int symbol_index;
extern int intermediate_index;
extern int blocks_index;
extern intermediate_lang **intermediate_table;
extern symbol_table **symbol_tab;
extern blocks_table **block_tab;

/**
 * @brief Displays the contents of the symbol table
 * 
 * This function prints the variable names, addresses, and sizes
 * from the symbol table to the console.
 */
void display_symbol_table(void) {
    if (symbol_index <= 0) {
        printf("\nSymbol Table is empty\n");
        return;
    }

    printf("\n---------------Symbol Table is ----------\n");
    printf("%-10s %-10s %-10s\n", "Variable", "Address", "Size");
    printf("----------------------------------------\n");
    
    for (int i = 0; i < symbol_index; i++) {
        printf("%-10s %-10d %-10d\n", 
               symbol_tab[i]->variable_name, 
               symbol_tab[i]->address, 
               symbol_tab[i]->size);
    }
    
    printf("----------------------------------------\n");
    return;
}

/**
 * @brief Displays the contents of the intermediate language table
 * 
 * This function prints the instruction numbers, opcodes, and parameters
 * from the intermediate language table to the console.
 */
void display_intermediate_table(void) {
    if (intermediate_index <= 0) {
        printf("\nInstruction Table is empty\n");
        return;
    }

    printf("\n---------------Instruction Table is ----------\n");
    printf("%-5s %-5s %-20s\n", "Line", "Op", "Parameters");
    printf("---------------------------------------------\n");
    
    for (int i = 0; i < intermediate_index; i++) {
        printf("%-5d %-5d ", 
               intermediate_table[i]->instruc_no, 
               intermediate_table[i]->opcode);
        
        for (int j = 0; intermediate_table[i]->parameters[j] != -1; j++) {
            printf("%d ", intermediate_table[i]->parameters[j]);
        }
        printf("\n");
    }
    
    printf("---------------------------------------------\n");
    return;
}

/**
 * @brief Displays the contents of the blocks table
 * 
 * This function prints the label names and instruction numbers
 * from the blocks table to the console.
 */
void display_block_table(void) {
    if (blocks_index <= 0) {
        printf("\nBlock Table is empty\n");
        return;
    }

    printf("\n---------------Block Table is ----------\n");
    printf("%-10s %-10s\n", "Label", "Address");
    printf("------------------------------------\n");
    
    for (int i = 0; i < blocks_index; i++) {
        printf("%-10s %-10d\n", 
               block_tab[i]->name, 
               block_tab[i]->instr_no);
    }
    
    printf("------------------------------------\n");
    return;
}

/**
 * @brief Writes the compiler output to a file
 * 
 * This function dumps the symbol table, blocks table, and intermediate
 * language table to an output file.
 */
void dump_to_file(void) {
    FILE *fp;
    fp = fopen("output.obj", "w");
    
    if (fp == NULL) {
        fprintf(stderr, "Error: Could not open output file\n");
        return;
    }

    /* Write symbol table */
    fprintf(fp, "---------------Symbol Table is----------\n");
    fprintf(fp, "%-10s %-10s %-10s\n", "Variable", "Address", "Size");
    fprintf(fp, "----------------------------------------\n");
    
    for (int i = 0; i < symbol_index; i++) {
        fprintf(fp, "%-10s %-10d %-10d\n", 
                symbol_tab[i]->variable_name, 
                symbol_tab[i]->address, 
                symbol_tab[i]->size);
    }

    /* Write block table */
    fprintf(fp, "\n--------------Block Table is----------\n");
    fprintf(fp, "%-10s %-10s\n", "Label", "Address");
    fprintf(fp, "------------------------------------\n");
    
    for (int i = 0; i < blocks_index; i++) {
        fprintf(fp, "%-10s %-10d\n", 
                block_tab[i]->name, 
                block_tab[i]->instr_no);
    }

    /* Write instruction table */
    fprintf(fp, "\n---------------Instruction Table is----------\n");
    fprintf(fp, "%-5s %-5s %-20s\n", "Line", "Op", "Parameters");
    fprintf(fp, "---------------------------------------------\n");
    
    for (int i = 0; i < intermediate_index; i++) {
        fprintf(fp, "%-5d %-5d ", 
                intermediate_table[i]->instruc_no, 
                intermediate_table[i]->opcode);
        
        for (int j = 0; intermediate_table[i]->parameters[j] != -1; j++) {
            fprintf(fp, "%d ", intermediate_table[i]->parameters[j]);
        }
        fprintf(fp, "\n");
    }
    
    fclose(fp);
    printf("Compilation successful. Output written to output.obj\n");
    return;
}

/**
 * @brief Evaluates a condition based on two operands and a condition code
 * 
 * @param operand1 First operand
 * @param operand2 Second operand
 * @param opcode Condition code (OP_EQ, OP_LT, etc.)
 * @return int 1 if condition is true, 0 otherwise
 */
int check_condition(int operand1, int operand2, int opcode) {
    switch (opcode) {
        case OP_EQ:
            return (operand1 == operand2) ? 1 : 0;
        
        case OP_LT:
            return (operand1 < operand2) ? 1 : 0;
        
        case OP_GT:
            return (operand1 > operand2) ? 1 : 0;
        
        case OP_LTEQ:
            return (operand1 <= operand2) ? 1 : 0;
        
        case OP_GTEQ:
            return (operand1 >= operand2) ? 1 : 0;
        
        default:
            fprintf(stderr, "Error: Unknown condition opcode: %d\n", opcode);
            return 0;
    }
}

/**
 * @brief Executes the compiled program
 * 
 * This function runs the virtual machine that executes the
 * intermediate language instructions.
 * 
 * @param memory_array Pointer to the memory array
 * @param memory_index Index of the last used memory location
 */
void executor(int *memory_array, int memory_index) {
    printf("\n--- Program Execution ---\n\n");
    
    if (intermediate_index <= 0) {
        printf("No instructions to execute\n");
        return;
    }
    
    /* Initialize registers to 0 */
    for (int i = 0; i < VARIABLE_MEMORY_START; i++) {
        memory_array[i] = 0;
    }
    
    /* Execute instructions */
    for (int i = 0; i < intermediate_index;) {
        int *params = intermediate_table[i]->parameters;
        
        switch (intermediate_table[i]->opcode) {
            case OP_READ:
                printf("Input: ");
                if (scanf("%d", &memory_array[params[0]]) != 1) {
                    fprintf(stderr, "Error: Invalid input\n");
                    /* Clear input buffer */
                    while (getchar() != '\n');
                    memory_array[params[0]] = 0;
                }
                break;
                
            case OP_MOV_MEM_TO_REG:
            case OP_MOV_REG_TO_MEM:
                memory_array[params[0]] = memory_array[params[1]];
                break;
                
            case OP_ADD:
                memory_array[params[0]] = memory_array[params[1]] + memory_array[params[2]];
                break;
                
            case OP_SUB:
                memory_array[params[0]] = memory_array[params[1]] - memory_array[params[2]];
                break;
                
            case OP_MUL:
                memory_array[params[0]] = memory_array[params[1]] * memory_array[params[2]];
                break;
                
            case OP_PRINT:
                printf("Output: %d\n", memory_array[params[0]]);
                break;
                
            case OP_IF:
                if (!check_condition(memory_array[params[0]], memory_array[params[1]], params[2])) {
                    /* Condition is false, jump to ELSE or ENDIF */
                    i = params[3] - 1;
                    continue;
                }
                break;
                
            case OP_JUMP:
                /* Unconditional jump */
                i = params[0] - 1;
                continue;
                
            default:
                fprintf(stderr, "Warning: Unknown opcode %d at instruction %d\n", 
                        intermediate_table[i]->opcode, intermediate_table[i]->instruc_no);
                break;
        }
        
        i++;
    }
    
    printf("\n--- End of Execution ---\n");
    return;
}
